{
  "hash": "6ac4bafbf96260bc0b6cfd995ffc96a4",
  "result": {
    "markdown": "---\ntitle: \"R の基本操作\"\n---\n\n\n\n\n## 代入演算子 (assignment operator) とベクトル (vector) とは\n\n\n* 代入は `=` か `<-` (`<` と `-`) です。伝統的に使われる代入は `<-` ですが、私は `=` を使っています。\n* 左辺は変数名、右辺は値です。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 二種類の代入と c() 関数\na = 4.2\nb <- 5.0\nc(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.2 5.0\n```\n:::\n:::\n\n\n* `c()` は渡された引数を結合します。\n* `#` の後から続く文字列はコードとして実行されません。実行されない文書はコメントと呼びます。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(a + b) * c(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 38.64 46.00\n```\n:::\n:::\n\n\n* R はベクトル処理という実行機構が特徴的です。\n* 上のコードは $(a + b) \\times a$ と $(a + b) \\times b$ を求めています。\n\nRStudio の場合 `<-` は `ALT + -` のショートカットを定義しています。\n\n\n## R の主なデータタイプとデータ構造\n\n* 整数 integer\n* 実数 double, numeric\n* 複素数 complex number\n* 時系列 time-series (POSIX)\n* 文字列 character\n* 論理値 logical\n* 因子 factor\n\n* ベクトル　vector\n* 配列 array, matrix\n* リスト list\n* テーブル（データフレーム） dataframe\n\n## データの作り方\n\n**ベクトル**\n\n::: {.cell}\n\n```{.r .cell-code}\na = c(10.3, 20.2, 30.1)\nb = c(\"rabbit\", \"cat\", \"mouse\", \"dog\")\nd = c(TRUE, FALSE, T)\ne = factor(c(\"nagasaki\", \"kagoshima\", \"fukuoka\"))\n```\n:::\n\n\n**リスト**\n\nベクトルの長さは異なってもいい。\nここでは、リストの要素名を指定しました。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz1 = list(\"A\" = a, \"B\"= b, \"D\" = d, \"E\" = e)\n```\n:::\n\n\n**データフレーム**\n\nベクトルの長さを揃える必要がある。\nここでは`b[1:3]`を`b`に渡すことで、変数名を指定しました。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz2 = data.frame(a, b = b[1:3], d, e)\n```\n:::\n\n\n## リストの構造を確認しよう\n\nRオブジェクトの構造 (structure) は `str()` で確認します。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(z1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 4\n $ A: num [1:3] 10.3 20.2 30.1\n $ B: chr [1:4] \"rabbit\" \"cat\" \"mouse\" \"dog\"\n $ D: logi [1:3] TRUE FALSE TRUE\n $ E: Factor w/ 3 levels \"fukuoka\",\"kagoshima\",..: 3 2 1\n```\n:::\n:::\n\n\n\n## リストからデータを抽出する\n\nリストの要素は次のように抽出できます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz1$A\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10.3 20.2 30.1\n```\n:::\n:::\n\n\nリストからの抽出方法は `$` 以外に, `[` や `[[` でもできます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz1[c(\"A\", \"D\")]\nz1[c(1,4)]\nz1[[2]]\nz1[[c(2,3)]]\nz1[[2]][c(1,2)]\n```\n:::\n\n\n---\n\n## データフレームの構造を確認しよう\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(z2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t3 obs. of  4 variables:\n $ a: num  10.3 20.2 30.1\n $ b: chr  \"rabbit\" \"cat\" \"mouse\"\n $ d: logi  TRUE FALSE TRUE\n $ e: Factor w/ 3 levels \"fukuoka\",\"kagoshima\",..: 3 2 1\n```\n:::\n:::\n\n\nリストと似ていますが、そもそもデータフレームはリストです。\nつまり、リストと同じように操作できます。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz2$a\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10.3 20.2 30.1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nz2[c(\"a\", \"d\")]\nz2[c(1, 4)]\nz2[[2]]\nz2[[c(2,3)]]\nz2[[2]][c(1,2)]\n```\n:::\n\n\n## 比較演算\n\n\n* 比較に使う論理演算子：`&`（論理積 AND）, `|` （論理和 OR）, `!`（否定 NOT）\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA = c(5, 3, 2)\nB = c(5, 2, 1)\n\n# 論理積\n(A[1] > B[1]) & (A[1] == B[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# 論理和\n(A[1] > B[1]) | (A[1] == B[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 否定と論理積\n!(A[1] > B[1]) & (A[1] == B[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# 否定と論理和\n(A[1] < B[2]) | !(A[1] == B[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n## 比較演算を使ったデータの抽出\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na = c(10.3, 20.2, 30.1)\nb = c(\"rabbit\", \"cat\", \"mouse\")\nd = c(TRUE, FALSE, T)\ne = factor(c(\"nagasaki\", \n             \"kagoshima\", \n             \"fukuoka\"))\nZ = data.frame(a, b, d, e)\nZ[Z$a > 20, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     a     b     d         e\n2 20.2   cat FALSE kagoshima\n3 30.1 mouse  TRUE   fukuoka\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nZ[Z$a > 10 & Z$a < 20.2, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     a      b    d        e\n1 10.3 rabbit TRUE nagasaki\n```\n:::\n\n```{.r .cell-code}\nZ[Z$a > 10 & Z$a <= 20.2, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     a      b     d         e\n1 10.3 rabbit  TRUE  nagasaki\n2 20.2    cat FALSE kagoshima\n```\n:::\n\n```{.r .cell-code}\nZ[identical(Z$a, 20) | !Z$d, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     a   b     d         e\n2 20.2 cat FALSE kagoshima\n```\n:::\n:::\n\n\n\n## **重要!** 数値を比較について\n\nパソコンは 2 進数で計算しているので、数値は正確ではない！\n\n**たとえば：**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0.2 * 0.2 / 0.2 == 0.2 # = と =\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n数値の比較をする場合は `all.equal()` を使いましょう。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(0.2 * 0.2 / 0.2, 0.2, tolerance = 0) # 上のコードと同じ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Mean relative difference: 1.387779e-16\"\n```\n:::\n\n```{.r .cell-code}\nall.equal(0.2 * 0.2 / 0.2, 0.2, tolerance = .Machine$double.eps) # 機械誤差を考慮した比較\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n* ちなみに比較用記号は `<`, `>`, `>=` (`>` と `=`), `<=` (`<` と `=`), `!=` (`!` と `=`), `==` (`=` と `=`)　です。\n\n",
    "supporting": [
      "part01_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}