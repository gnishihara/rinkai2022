{
  "hash": "9e2395b13eba984e962296b0222b6bcc",
  "result": {
    "markdown": "---\ntitle: \"Tidyverse\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.3.6      ✔ purrr   0.3.4 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.0      ✔ stringr 1.4.0 \n✔ readr   2.1.2      ✔ forcats 0.5.1 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n:::\n\n\n\n# `tidyverse` \n\n> Hadley Wickhamが開発した、タイディバースはRのプログラマーの中で最も使われているデータ分析パッケージです。\n> データの読み込み、抽出、加工、可視化を助けてくれる関数の解析システムです。\n> `tidyverse` の基礎となるアイディアは `tidy` な解析コードを開発することです。\nつまり、だれでも読めるすぐに実行できるコードのことですね。\n\n## `tidyverse`\n\n`tidyverse` はメタパッケージなので、`library(tidyverse)` を実行すると次の 8 つのパッケージが読み込まれます。\n\n* dplyr：データの変形・加工\n* forcats：`factor()` 因子が使いやすくなります\n* ggplot2：データの可視化・作図\n* purrr ：関数型プログラミング\n* readr ：CSV、TSVデータの読み込み\n* stringr ：文字列の操作が楽になる\n* tibble ：データフレームの操作が楽になる\n* tidyr ：データをタイディ (tidy) にして操作しやすくなる\n\n`tidyverse` の概念をもっと知りたい方は[tidyverse のマニフェスト](https://cran.r-project.org/web/packages/tidyverse/vignettes/manifesto.html)を読みましょう。\n\n# Data I/O\n\nデータ解析をするためには, データを `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} に読み込む必要があります。\n\nベースRの関数または外部パッケージの関数を使えば, 様々なデータファイルを簡単に読み込めます。\n\n## `tibble` には list 列を入れられる\n\n\nちょっと高度の方法ですが, list を変数の要素として記録できます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\na1 = list(1,5,1,3,5,1)\na2 = list(2,3,5,2)\na3 = list(\"A\",\"b\",\"E\")\ntibble(a = 1:3, values = list(a1, a2, a3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n      a values    \n  <int> <list>    \n1     1 <list [6]>\n2     2 <list [4]>\n3     3 <list [3]>\n```\n:::\n:::\n\n\n`values` 列は list の list ですね。\n\n\n\n::: {.cell engine.opts='{\"template\":\"tikz.latex\"}'}\n::: {.cell-output-display}\n![](part03_files/figure-html/unnamed-chunk-3-1.png){width=70%}\n:::\n:::\n\n\n\n## 列名・変数名について\n\n`data.frame()` は無効な変数名を自動的に変更します。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(`1 name` = 1) |> names()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"X1.name\"\n```\n:::\n:::\n\n\n`tibble()` はそのままにしてくれます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(`1 name` = 1) |> names()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1 name\"\n```\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n**`data.frame()`の場合**\n* **有効な変数名：**文字または、ドット(.)と文字から始まる文字列。変数名に使用できるものは文字、数字、ドットとアンダースコア (_) だけです。\n* **無効な変数名の例：**`2021FY`, `2021 FY`, `2020-FY`, `FY-2021` は自動的に `X2021FY`, `X2021.FY`, `X2020.FY`, `FY.2021` に変更されます。\n\n**`tibble()`の場合**\n* 変数名はそのまま使えますが、使うときは `` ` `` `` ` `` （バクチック）に囲んでください。\n\n**ところが!**\nどうしても `data.frame()` に無効な変数名を使いたいのであれば、`check.names = F` を渡してください。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(`1 name` = 1, check.names = FALSE) |> names()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1 name\"\n```\n:::\n:::\n\n\n## 引数を連続的に使える\n\n`tibble()`はこのように, 計算処理をしながらデータフレームを構築できます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = 1:4, `x^2` = x^2, `sqrt(x)` = sqrt(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n      x `x^2` `sqrt(x)`\n  <int> <dbl>     <dbl>\n1     1     1      1   \n2     2     4      1.41\n3     3     9      1.73\n4     4    16      2   \n```\n:::\n:::\n\n\n\n## ベクトルをリサイクルしない\n\n二つのベクトルの長さが異なるときに, データフレームを作ると, 小さいほうのベクトルは先頭から繰り返して使われます。ただし長いベクトルの要素数は短いベクトルの要素数で除算できる必要があります。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 1:4\ny = 1:8\ndata.frame(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y\n1 1 1\n2 2 2\n3 3 3\n4 4 4\n5 1 5\n6 2 6\n7 3 7\n8 4 8\n```\n:::\n:::\n\n\nところが, この機能はデータ解析時にバグの原因になります。`tibble()`はベクトルのリサイクルはできません。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 1:4\ny = 1:8\ntibble(x, y)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError:\n! Tibble columns must have compatible sizes.\n• Size 4: Existing data.\n• Size 8: Column at position 2.\nℹ Only values of size one are recycled.\n```\n:::\n:::\n\n\n## I/O 関係の関数\n\n**読み込み関数**\n\n* `read_delim()`：一般性の高い関数, 区切りの指定が必要\n* `read_csv()`：コンマ区切りフィアルの読み込み（csv ファイル）\n* `read_table()`：ホワイトスペース区切りファイルの読み込み（タブ・スペース区切りファイル）\n* `read_rds()`：R オブジェクトの読み込み\n\n**書き出し関数**\n\n* `write_delim()`：一般性の高い関数, 区切りの指定が必要\n* `write_csv()`：コンマ区切りフィアルの書き出し\n* `write_table()`：ホワイトスペース区切りファイルの書き出し（タブ・スペース区切りファイル）\n* `write_rds()`：R オブジェクトの書き出し\n* `ggsave()`: `ggplot2` でつくった図を書き出し\n\n## `read_csv()` の重要な引数\n\n* `file`：パスとファイル名\n* `col_names = TRUE`：TRUEのとき, 1行目は列名として使う, FALSE のときは列名を自動的に作成する, 文字列ベクトルを渡せば読み込み中に列名を付けられます\n* `col_types = NULL`：列のデータ型を指定できるが NULL のときは関数に任せる\n* `comment = \"\"`：コメント記号を指定し, コメント記号後の文字を無視する\n* `skip = 0`             先頭から無視する行数\n* `locale`：ロケール（地域の設定）\n* `n_max = Inf`：読み込む行数、デフォルトは全ての行数\n\n\n## `read_csv()`の使い方\n\n`read_csv()`\n\n::: {.cell}\n\n```{.r .cell-code}\nrabbits = read_csv(\"Assignment_06_Dataset01.csv\")\nrabbits\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\nRows: 37 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): host\ndbl (1): scutum.width\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 37 × 2\n   host    scutum.width\n   <chr>          <dbl>\n 1 Rabbit1          380\n 2 Rabbit1          376\n 3 Rabbit1          360\n 4 Rabbit1          368\n 5 Rabbit1          372\n 6 Rabbit1          366\n 7 Rabbit1          374\n 8 Rabbit1          382\n 9 Rabbit2          350\n10 Rabbit2          356\n# … with 27 more rows\n```\n:::\n:::\n\n\n\n## readxl パッケージ\n\n`readxl` は Microsoft Excelファイルの読み込みに使えるパッケージです。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\n```\n:::\n\n\nファイルの読み込みには `read_excel()` を使いますが、研究室では `read_xlsx()` もよく使います。\n`read_excel()` は `read_xlsx()` のラッパーです。\n使い方は全くおなじです。\n\n**重要：** エクセルでデータの管理をした場合エクセルのオートコレクト機能によってデータがかってに変換されるので気をつけましょう。遺伝子の名前のオートコレクトによく問題が発生すると報告されています。とくに Excel と Google Sheets のオートコレクトはアグレッシブです。[Abeysooriya et al. 2021. PLOS Computational Biology](https://doi.org/10.1371/journal.pcbi.1008984)。\n\n\n## `read_excel()` の主な引数\n\n* `path`：パスとファイル名\n* `sheet = NULL`：読み込むシート名またはシートインデックス\n* `range = NULL`：読み込む範囲, 例えば \"B3:D8\" または, \"Data!B3:D8\"\n* `col_names = TRUE`：1行目を列名として使う論理値\n* `col_types = NULL`：読み込む列のデータ型を指定できます (デフォルトは guess)\n* `na = \"\"`：欠損値の定義, 空セルは欠損値とされます\n* `skip = 0`：無視する行数\n* `n_max = Inf`：読み込む最大行数\n\n## `read_excel()` の使用例（１）\n\n最初のシート (`sheet = 1`) の先頭から1行無視して (`skip = 1`) データを読み込む。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilename = \"Table 2.xlsx\"\nexceldata = read_excel(filename, sheet = 1, skip = 1)\nexceldata\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\nNew names:\n• `WT (˚C)` -> `WT (˚C)...2`\n• `S.D.**` -> `S.D.**...3`\n• `` -> `...4`\n• `WT (˚C)` -> `WT (˚C)...5`\n• `S.D.**` -> `S.D.**...6`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 6\n   Month `WT (˚C)...2` `S.D.**...3` ...4  `WT (˚C)...5` `S.D.**...6`\n   <chr>         <dbl>        <dbl> <lgl>         <dbl>        <dbl>\n 1 Jan.           21.1        0.446 NA             16.5        0.428\n 2 Feb.           21.3        0.441 NA             16.3        0.483\n 3 Mar.           21.5        0.470 NA             16.5        0.579\n 4 Apr.           21.8        0.554 NA             18.3        1.27 \n 5 May            23.4        0.726 NA             21.1        1.08 \n 6 Jun.           25.5        1.20  NA             22.9        1.02 \n 7 Jul.           28.6        0.491 NA             26.6        1.15 \n 8 Aug.           28.8        0.546 NA             28.5        0.470\n 9 Sep.           28.5        0.375 NA             27.7        0.794\n10 Oct.           26.6        0.893 NA             24.4        1.05 \n11 Nov.           24.7        0.516 NA             21.6        0.928\n12 Dec.           22.8        0.720 NA             19.1        0.893\n```\n:::\n:::\n\n\n\n## `read_excel()` の使用例（２）\n\n先程のように読み込むと、不都合な変数名に変換されました。次は、変数名も指定して読み込みます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilename = \"Table 2.xlsx\"\ncol_names = c(\"month\", \"temperature1\", \"sd1\", \"empty\",\"temperature2\", \"sd2\")\nexceldata = read_excel(filename, sheet = 1, skip = 2, col_name = col_names)\nexceldata |> print(n = 4)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 6\n  month temperature1   sd1 empty temperature2   sd2\n  <chr>        <dbl> <dbl> <lgl>        <dbl> <dbl>\n1 Jan.          21.1 0.446 NA            16.5 0.428\n2 Feb.          21.3 0.441 NA            16.3 0.483\n3 Mar.          21.5 0.470 NA            16.5 0.579\n4 Apr.          21.8 0.554 NA            18.3 1.27 \n# … with 8 more rows\n```\n:::\n:::\n\n\nシートの２行目には変数名が記録されているので、`skip = 2` を渡しました。\n\n## データの出力\n\n**CSVファイルの出力**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfname = \"table2_output.csv\"\nexceldata |> write_csv(file = fname) # 文字コードは UTF-8 です。\n```\n:::\n\n\nエクセルにCSVファイルを読み込んで文字化けした場合、`write_excel_csv()`を試してみてください。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexceldata |> write_excel_csv(file = fname)\n```\n:::\n\n\n**RDSファイルの出力**\n\nRのオブジェクトをバイナリファイルとして保存したい場合は `write_rds()` を使います。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfname = \"table2_output.rds\"\nexceldata |> write_rds(file = fname)\n```\n:::\n",
    "supporting": [
      "part03_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}